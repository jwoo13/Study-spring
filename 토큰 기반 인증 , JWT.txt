사용자가 서버에 접근할 때 이 사용자가 인증된 사용자인지 확인하는 방법은 다양함

대표적으로 서버 기반 인증과 토큰 기반 인증이 있다

스프링 시큐리티에서는 기본적으로 세션 기반 인증을 제공
-기본적으로 제공해주는 세션 기반 인증을 사용해 사용자마다 사용자의 정보를 담는 세션을 생성하고
 저장해서 인증을 합니다.

토큰 기반 인증은 토큰을 사용하는 방법
-토큰은 서버에서 클라이언트를 구분하기 위한 유일한 값인데 서버가 토큰을 생성해서 클라이언트에게 제공하면 클라이언트는 이 토큰을 갖고 있다가 여러 요청을 이 토큰과 함께 신청합니다.
그럼 서버는 토큰만 보고 유효한 사용자인지 검증한다.

토큰을 전달하고 인증 받는 과정
1.클라이언트가 아이디와 비밀번호를 서버에게 전달하면서 인증을 요청하면

2.서버는 아이디와 비밀번호를 확인해 유효한 사용자인지 검증합니다.유효한 사용자면 토큰을 생성해서 응답합니다.

3.클라이언트는 서버에서 준 토큰을 저장합니다.

4.이후 인증이 필요한 API를 사용할 때 토큰을 함께 보냅니다

5.그러면 서버는 토큰이 유효한지 검증합니다.

6 토큰이 유효하다면 클라이언트가 요청한 내용을 처리합니다.

토큰 기반인증 특징

무상태성
사용자의 인증 정보가 담겨 있는 토큰이 서버가 아닌 클라이언트에 있으므로 서버에 저장할 필요없음
서버가 뭔가 데이터를 유지하고 있으려면 그만큼 자원을 소비해야함
그런데 토큰 기반 인증에서는 클라이언트에서 인증 정보가 담긴 토큰을 생성하고 인증합니다.
따라서 클라이언트에서는 사용자의 인증 상태를 유지하면서 이후 요청을 처리해야 하는데
이것을 상태를 관리한다고 함
이렇게 하면 서버 입장에서는 클라이언트의 인증 정보를 저장하거나 유지하지 않아도 되기 때문에 완전한 무상태로 효율적인 검증을 할 수 있습니다.

확장성
무상태성은 확장성에 영향을 준다.
서버를 확장할때 상태 관리를 신경 쓸 필요가 없으니 서버확장에도 용이함
예)
물건을 파는 서비스가 있고 결제를 위한 서버와 주문을 위한 서버가 분리되어 있다고 가정했을때
세션 인증 기반은 각각 API에서 인증을 해야 되는 것과는 달리 토큰 기반 인증에서는 토큰을 가지는 주체는 서버가 아니라 클라이언트이기 때문에 가지고 있는 하나의 토큰으로 결제 서버와 주문 서버에게 요청을 보낼 수 있다.
추가로 페이스북 로그인 , 구글 로그인 같이 토큰 기반 인증을 사용하는 다른 시스템에 접근해 로그인 방식을 확장할 수도 있고 , 이를 활용해 다른 서비스에 권한을 공유할 수도 있다

무결성
토큰 방식은 HMAC기법이라고도 함 토큰을 발급한 이후에는 토큰 정보를 변경하는 행위 불가능
즉 토큰의 무결성이 보장됨
만약 누군가 토큰을 한 글자라도 변경하면 서버에선느 유효하지 않은 토큰이라고 판단함


JWT(Json web tokken)
발급받은 JWT를 이용해 인증을 하려면 HTTP 요청 헤더 중에 Authorization 키값에 Bearer + JWT 토큰값을 넣어 보내줘야함

JWT 구조
JWT는 .(점)을 기준으로 헤더,내용,서명으로 이루어짐
예) aaaaa . bbbbb . ccccc
    헤더  |    내용	   | 서 명

헤더에는 토큰의 타입과 해싱 알고리즘을 지정하는 정보를 담고 있다.
JWT 토큰 , HS256 해싱 알고리즘 사용하는 예)
{
	"typ": "JWT",
	"alg": "HS256"
}
해더의 구성
typ 는 토큰의 타입을 지정합니다. JWT라는 문자열이 들어감
alg 는 해싱 알고리즘을 지정함

내용에는 토큰과 관련된 정보를 담음 내용의 한 덩어리를 클레임이라고 부르며
클레임은 키값의 한 쌍으로 이루어져 있다.
클레임은 등록된 클레임, 공개 클레임, 비공개 클레임으로 나눌 수 있음

등록된 클레임은 토큰에 대한 정보를 담는데 사용
iss - 토큰 발급자
sub - 토큰 제목
aud - 토큰 대상자
exp - 토큰의 만료 시간, 시간은 NumericDate형식으로 하며,항상 현재 시간 이후로 설정
nbf - 토큰의 활성 날짜와 비슷한 개념으로 nbf는 not Before를 의미함. NumericDate 형식으로 날짜를 지정하며 이 날짜가 지나가기 전까지는 토큰이 처리되지 않음
iat - 토큰이 발급된 시간으로 iat은 issued at을 의미함
jti - JWT 의 고유 식별자로서 주로 일회용 토큰에서 사용

공개 클레임은 공개되어도 상관없는 클레임을 의미
충돌을 방지할 수 있는 이름을 가져야하며 보통 클레임 이름을 URI로 짓는다

비공개 클레임은 공개되면 안되는 클레임을 의미,클라이언트와 서버 간의 통신에 사용

JWT 예)
{
	"iss" : "ajufresh@gmail.com", //등록된 클레임
	"iat" : "162237079", //등록된 클레임
	"exp" : "162258079", //등록된 클레임
	"https://siwnrrw.com/jwt_claims/is_damin": true, // 공개클레임
	"email" : "ajufresh@gmail.com", // 비공개 클레임
	"hello" : " 안녕하세여!" //비공개 클레임
}

iss,iat,exp는 JWT 자체에서 등록된 클레임이고
URI로 네이밍된https://siwnrrw.com/jwt_claims/is_damin는 공개 클레임
email과 hello는 비공개 클레임 값이다

서명
서명은 해당 토큰이 조작되었거나 변경되지 않았음을 확인하는 용도로 사용하며,
헤더의 인코딩값과 내용의 인코딩값을 합친 후에 주어진 비밀키를 사용해 해시값을 생성


토큰 유효기간
토큰을 주고 받는 환경이 보안에 취약해서 토큰 자체가 노출되면
토큰은 이미 발급되면 그 자체로 인증 수단이 되므로 서버느 토큰과 함꼐 들어온 요청이 토큰을 탈취한 사람의 요청인지 확인할 수 없음
그래서 해결 방안으로 리프레시 토큰이 나옴

토큰의 유효기간이 하루면 하루 동안 그 토큰으로 무엇이든지 할 수 있을테니 큰일임
그러면 토큰의 유효기간을 짧게하면 사용자입장에서 너무 짧은 시간에만 사용하니 불편함
이러한 불편한 점을 해결하기 위해 리프레시 토큰이 등장

리프레시 토큰은 액세스 토큰과 별개의 토큰이다
사용자를 인증하기 위한 용도가 아닌 액세스 토큰이 만료되었을때 새로운 액세스 토큰을 발급하기 위해 사용함
액세스 토큰의 유효 기간은 짧게 설정하고 리프레시 토큰의 유효 기간은 길게 설정하면 공격자가 액세스 토큰을 탈취해도 몇 분 뒤에는 사용할 수 없는 토큰이 됨

구조는
1.클라이언트가 서버에게 인증을 요청
2.서버는 클라이언트에서 전달한 정보를 바탕으로 인증 정보가 유효한지 확인한 뒤 액세스 토큰과 리프레시 토큰을 만들어 클라이언트에게 전달하고 클라이언트는 전달받은 토큰을 저장
3. 서버에서 생성한 리프레시 토큰은 DB에도 저장해둠
4.인증을 필요로 하는 API를 호출할 때 클라이언트에서 저장된 액세스 토큰과 함께 API를 요청
5.서버에서 전달받은 액세스 토큰이 유효한지 검사한 뒤에 유효하다마면 클라이언트에서 요청한 내용을 처리
6.시간이 지나고 액세스 토큰이 만료된 뒤에 클라이언트에서 원하는 정보를 얻기 위해 서버에게 API 요청을 보냅니다.
7.서버에서 액세스 토큰이 유요한지 검사합니다 만료된 토큰이면 유효하지 않기 때문에 토큰이 만료되었다는 에러 전달
8.
클라이언트에서는 이 응답을 받고 저장해둔 리프레시 토큰과 함께 새로운 액세스 토큰을 발급하는 요청을 전송
9.서버에선느 전달받은 리프레시 토큰이 유효한지,DB에서 리프레시 토큰을 조회한 후 저장해둔 리프레시 토큰과 같은지 확인
10.만약 유효한 리프레시 토큰이라면 새로운 액세스 토큰을 생성한 뒤 응답함 그 이후에 클리이언트는 4번과 같이 다시 API를 요청함

토큰 필터는 실제로 각종 요청이 요청을 처리하기 위한 로직으로 전달되기 전후에 URL 패턴에 맞는 모든 요청을 처리하는 기능을 제공
요청이 오면 헤더값을 비교해서 토큰이 있는지 확인하고 유효 토큰이라면 시큐리티 콘텍스트 홀더에 인증 정보를 저정함

시큐리티 컨텐스트는 인증 객체가 저장되는 보관소이다
여기서 인증 정보가 필요할 때 언제든지 인증 객체를 꺼내 사용할 수 있다
이 클래스는 스레드마다 공간을 할당하는 스레드 로컬에 저장되므로 코드의 아무 곳에서나 참조할 수 있고
다른 스레드와 공유하지 않으므로 독립적으로 사용할 수 있다.
그리고 이러한 시큐리티 컨텍스트 객체를 저장하는 객체가 시큐리티 컨텍스츠 홀더이다